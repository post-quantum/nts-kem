/**
 *  ff.c
 *  NTS-KEM
 *
 *  Parameter: NTS-KEM(13, 80)
 *
 *  This file is part of the reference implemention of NTS-KEM
 *  submitted as part of NIST Post-Quantum Cryptography
 *  Standardization Process.
 **/

#include <stdlib.h>
#include <string.h>
#include "ff.h"

ff_unit ff_add_m(const FF2m* ff2m, ff_unit a, ff_unit b)
{
    return a ^ b;
}

ff_unit ff_reduce_13(uint32_t a)
{
    uint32_t u;
    
    /* GF(2^13), generated by f(x) = x^13 + x^4 + x^3 + x + 1 */
    u  = a & 0x1FF0000;
    a ^= (u >>  9);
    a ^= (u >> 10);
    a ^= (u >> 12);
    a ^= (u >> 13);
    
    u  = a & 0x000E000;
    a ^= (u >>  9);
    a ^= (u >> 10);
    a ^= (u >> 12);
    a ^= (u >> 13);
    
    return (ff_unit)(a & 0x1FFF);
}

ff_unit ff_mul_13(const FF2m* ff2m, ff_unit a, ff_unit b)
{
    uint32_t t;
    
    /* Perform shift-and-add multiplication */
    t  = a * (b & 1);
    t ^= (a * (b & 0x0002));
    t ^= (a * (b & 0x0004));
    t ^= (a * (b & 0x0008));
    t ^= (a * (b & 0x0010));
    t ^= (a * (b & 0x0020));
    t ^= (a * (b & 0x0040));
    t ^= (a * (b & 0x0080));
    t ^= (a * (b & 0x0100));
    t ^= (a * (b & 0x0200));
    t ^= (a * (b & 0x0400));
    t ^= (a * (b & 0x0800));
    t ^= (a * (b & 0x1000));
    
    /* Return the modulo reduction of t */
    return ff_reduce_13(t);
}

ff_unit ff_sqr_13(const FF2m* ff2m, ff_unit a)
{
    uint32_t b = a;
    
    b = (b | (b << 8)) & 0x00FF00FF;
    b = (b | (b << 4)) & 0x0F0F0F0F;
    b = (b | (b << 2)) & 0x33333333;
    b = (b | (b << 1)) & 0x55555555;
    
    return ff_reduce_13(b);
}

ff_unit ff_inv_13(const FF2m* ff2m, ff_unit a)
{
    ff_unit a3, a15, b;
    
    a3 = ff_sqr_13(ff2m, a);        /* a^2 */
    a3 = ff_mul_13(ff2m, a3, a);    /* a^3 */
    
    a15 = ff_sqr_13(ff2m, a3);      /* a^6 */
    a15 = ff_sqr_13(ff2m, a15);     /* a^12 */
    a15 = ff_mul_13(ff2m, a15, a3); /* a^15 */
    
    b = ff_sqr_13(ff2m, a15);       /* a^30 */
    b = ff_sqr_13(ff2m, b);         /* a^60 */
    b = ff_sqr_13(ff2m, b);         /* a^120 */
    b = ff_sqr_13(ff2m, b);         /* a^240 */
    b = ff_mul_13(ff2m, b, a15);    /* a^255 */
    
    b = ff_sqr_13(ff2m, b);         /* a^510 */
    b = ff_sqr_13(ff2m, b);         /* a^1020 */
    b = ff_mul_13(ff2m, b, a3);     /* a^1023 */
    
    b = ff_sqr_13(ff2m, b);         /* a^2046 */
    b = ff_sqr_13(ff2m, b);         /* a^4092 */
    b = ff_mul_13(ff2m, b, a3);     /* a^4095 */

    return ff_sqr_13(ff2m, b);      /* a^8190 */
}

FF2m* ff_create()
{
    int i;
#if defined(INTERMEDIATE_VALUES)
    ff_unit a;
#endif
    FF2m *ff2m = NULL;
    
    if (!(ff2m = (FF2m *)malloc(sizeof(FF2m))))
        return NULL;
    
    ff2m->m = 13;
    ff2m->ff_add = &ff_add_m;
    ff2m->ff_mul = &ff_mul_13;
    ff2m->ff_sqr = &ff_sqr_13;
    ff2m->ff_inv = &ff_inv_13;
#if defined(INTERMEDIATE_VALUES)
    ff2m->log2poly = (ff_unit *)calloc(1<<ff2m->m, sizeof(ff_unit));
    ff2m->poly2log = (ff_unit *)calloc(1<<ff2m->m, sizeof(ff_unit));
    if (!ff2m->log2poly || !ff2m->poly2log) {
        return 0;
    }
    ff2m->log2poly[0] = 1; ff2m->poly2log[0] = 0xFFFF;
    for (i=1; i<(1<<ff2m->m)-1; i++) {
        a  = ff2m->log2poly[i-1] << 1;
        a ^= (((a & (1 << ff2m->m)) >> ff2m->m) * 0x201b); /* x^13 + x^4 + x^3 + x + 1 */
        ff2m->log2poly[i] = a; ff2m->poly2log[a] = i;
    }
#endif /* INTERMEDIATE_VALUES */

    /**
     * Basis, B = <beta^{m-1},beta^{m-2},...,beta,1>
     **/
    if (!(ff2m->basis = (ff_unit *)calloc(ff2m->m, sizeof(ff_unit))))
        return 0;
    for (i=0; i<ff2m->m; i++) {
        ff2m->basis[ff2m->m-i-1] = (1 << i);
    }
    
    return ff2m;
}

void ff_release(FF2m* ff2m)
{
    if (ff2m) {
#if defined(INTERMEDIATE_VALUES)
        if (ff2m->log2poly) {
            memset(ff2m->log2poly, 0, (1<<ff2m->m)*sizeof(ff_unit));
            free(ff2m->log2poly); ff2m->log2poly = NULL;
        }
        if (ff2m->poly2log) {
            memset(ff2m->poly2log, 0, (1<<ff2m->m)*sizeof(ff_unit));
            free(ff2m->poly2log); ff2m->poly2log = NULL;
        }
#endif
        if (ff2m->basis) {
            memset(ff2m->basis, 0, ff2m->m*sizeof(ff_unit));
            free(ff2m->basis); ff2m->basis = NULL;
        }
        ff2m->m = 0;
        ff2m->ff_add = NULL;
        ff2m->ff_mul = NULL;
        ff2m->ff_sqr = NULL;
        ff2m->ff_inv = NULL;
        free(ff2m);
    }
}
